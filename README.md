# `solabi`

![crates.io](https://img.shields.io/crates/v/solabi)
![docs.rs](https://img.shields.io/docsrs/solabi)

Solidity ABI implementation in Rust.

## Introduction

This crate aims to provide a comprehensive toolkit for working with the Solidity
ABI in Rust, including encoding and decoding values as well as parsing JSON ABI
generated by the Solidity complier.

## Usage

Just add `solabi` as a dependency!

```toml
solabi = "*"
```

`solabi` depends on the [`ethprim`](https://docs.rs/ethprim) crate which gets
re-exported as `solabi::ethprim`. This crate notably includes procedural macros
for compile-time computed literals (for things like 256-bit integers and
checksummed addresses) as well as compile-time computed Keccak-256 digests. To
build with macro support:

```toml
solabi = { version = "*", features = ["macros"] }
```

```rust
use solabi::ethprim::*;

const DIGEST: Digest = keccak!("hello world!");
const PRIME: I256 = int!("57896044618658097711785492504343953926634992332820282019728792003956564819949");
const ADDRESS: Address = address!("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045");
```

## Future Work

While the core components of the Solidity ABI implementation are mostly
complete, there are a couple of features that expected to be implemented before
`v1` of this crate, namely:

- [ ] Procedural macros for Solidity ABI item generation. This includes
      generating types for encoding and decoding Solidity contract items. While
      the exact API is not yet determined, it is expected to look something
      like:

      ```rust
      #[derive(solabi::Function)]
      #[solabi(signature = "function transferFrom(address, address, uint256) returns (bool)")]
      struct TransferFrom;

      #[derive(solabi::Event)]
      struct Transfer {
          #[solabi(indexed)]
          pub from: Address,
          #[solabi(indexed)]
          pub to: Address,
          pub value: U256,
      }

      fn main() {
          TransferFrom.encode_params(...);
          TransferFrom.decode_result(...);

          Transfer { ... }.encode();
          Transfer::decode(Log {
              topics: ...,
              data: ...,
          })
      }
      ```
- [ ] Derive macro for `Encode` and `Decode`.

      ```rust
      #[derive(solabi::Decode, solabi::Encode)]
      struct MyStruct {
          name: String,
          age: uint256,
          occupation: Occupation,
      }

      #[derive(solabi::Decode, solabi::Encode)]
      enum Occupation {
          Crypto,
          Other,
      }
      ```
